// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.DeepSpace2019.subsystems;


import org.usfirst.frc1735.DeepSpace2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class HatchGrabber extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    private static final double kAccelTime = .1;
    private static final int kToleranceDistUnits = 1;
    private static final double kHatchP = 2;
    private static final double kHatchI = 0;
    private static final double kHatchD = 0;
    private static final double kMinGrabValue = 0; // encoder val for min release position (Safety)
    private static final double kMaxGrabValue = 0; // encoder val for max grab extension (Safety)
    public static final double kGrabSetpoint = 0; // desired encoder val for grab position
    public static final double kReleaseSetpoint = 0; // desired encore val for release position
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX hatchGrabberMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public HatchGrabber() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        hatchGrabberMotor = new WPI_TalonSRX(6);
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // Do initialization that cannot be done in the constructor because robot.init isn't executed yet so we don't have a gyro instance.
        
        //-----------------------------
        // Talon closed-loop configuration
        //-----------------------------

        // Chose the sensor and direction
        hatchGrabberMotor.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, 0); // extra args are:  primary closed loop, timeout in ms
        hatchGrabberMotor.setSensorPhase(true); //Assume inversion
        
        // Voltage compensation mode should make 100% output request scale to 12V regardless of battery voltage.
        // (if battery voltage is less than 12v it will just put all available voltage out)
        hatchGrabberMotor.enableVoltageCompensation(true);
        
        // Set the desired 100% at 12V
        hatchGrabberMotor.configVoltageCompSaturation(12.0, 0);
        
        // Encoder setup:  Since we are using the CTRE Mag Encoders, we do not
        // need to configure anything further
        
        // Closed-loop PID initialization/configuration
        //
        // See full code example at https://github.com/CrossTheRoadElec/FRC-Examples-STEAMWORKS/blob/master/JAVA_MotionMagicExample/src/org/usfirst/frc/team217/robot/Robot.java
        // General documentation on CTRE examples at https://github.com/CrossTheRoadElec/Phoenix-Examples-Languages/tree/master/Java

        // set the peak and nominal outputs, -1 to 1 in percentage of nominal voltage (even if battery voltage is higher)
        hatchGrabberMotor.configNominalOutputForward(0.0, 0);
        hatchGrabberMotor.configNominalOutputReverse(-0.0, 0);
        hatchGrabberMotor.configPeakOutputForward(1.0,0);
        hatchGrabberMotor.configPeakOutputReverse(-1.0,0);

        // set closed loop gains in slot0 - see documentation
        hatchGrabberMotor.selectProfileSlot(0,0);

        // Set the closed loop ramp as well (time in seconds to full speed; timeout)
        hatchGrabberMotor.configClosedloopRamp(kAccelTime, 0); //want to get to full speed in x sec

        //Set the closed-loop allowable error.  Empirically on no-load, error was x units.
        hatchGrabberMotor.configAllowableClosedloopError(0, (int) kToleranceDistUnits, 0); // index, err, timeout in ms
        
        // Some packet frames default to updating at 160ms, which is waaaay too slow for our 20ms DS periodic interval!
        // CTRE recommends that you set relevant frame periods to be at least as fast as periodic rate-- their example uses:
        hatchGrabberMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, 0);
        hatchGrabberMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, 0);
        hatchGrabberMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, 0);
        hatchGrabberMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, 0);


        // Throw a lot of settings up on the SmartDashboard...
        SmartDashboard.putNumber("Hatch P", kHatchP);
        SmartDashboard.putNumber("Hatch I", kHatchI);
        SmartDashboard.putNumber("Hatch D", kHatchD);
        
        // initialize the current position of the Hatchgrabber as "0" for the sensor.
        // This does imply that the alien hatchgrabber must be in the stowed/released position upon robot power-on!
        // if not, then the current position will become "stowed" and Bad Things will happen.
        hatchGrabberMotor.setSelectedSensorPosition(0);

    	hatchGrabberMotor.setInverted(false); // Assume no motor inversion
       	//Set the mode to Position.  Second arg is the setpoint.
        hatchGrabberMotor.set(ControlMode.Position, 0);
    	// Put the Talons in "Brake" mode for better accuracy
    	hatchGrabberMotor.setNeutralMode(NeutralMode.Brake);

    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void hatchGrabberMove(double magDir) {
        // use magDir as the new setpoint for the already-running PID controller
        if ((magDir > kMaxGrabValue) |
            (magDir < kMinGrabValue)) {
                // Error:  we are out of the legal operating range.
                System.out.println("Error:  HatchGrabber setpoint is outside of allowable range.\n" +
                                   "Range min:max = " + kMinGrabValue + ":" + kMaxGrabValue + ", requested value is = " + magDir);
        }
        else {
            this.hatchGrabberMotor.set(ControlMode.Position, magDir);
        }
    }

    //variables for controlling direction
    public static final double stop=0;
    public static final double out=1.0;
    public static final double in=-1.0;
}

