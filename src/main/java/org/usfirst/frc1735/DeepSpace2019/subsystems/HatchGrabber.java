// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.DeepSpace2019.subsystems;


import org.usfirst.frc1735.DeepSpace2019.Robot;
import org.usfirst.frc1735.DeepSpace2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import java.util.Map;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class HatchGrabber extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    private static final double kAccelTime = .1;
    private static final int kToleranceDistUnits = 1;
    private static final double kHatchP = 2;
    private static final double kHatchI = 0;
    private static final double kHatchD = 0;
    private static final double kMinGrabValue = 0; // encoder val for min release position (Safety)
    private static final double kMaxGrabValue = 500000; // encoder val for max grab extension (Safety)
    public static final double kGrabSetpoint = 0; // desired encoder val for grab position
    public static final double kReleaseSetpoint = 0; // desired encore val for release position
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX hatchGrabberMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public HatchGrabber() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        hatchGrabberMotor = new WPI_TalonSRX(6);
        
        
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        if (!Robot.isPracticeBot()) {
            // Put code here to be run every loop
            m_hatchGrabberEncoderEntry.setDouble(hatchGrabberMotor.getSelectedSensorPosition());
        }

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initHatchGrabber() {
        // Do initialization that cannot be done in the constructor because robot.init isn't executed yet so we don't have a gyro instance.
        // Only intialize the hatchGrabberMotor if we are on a production robot.
        if (!Robot.isPracticeBot()) {
            //-----------------------------
            // Talon closed-loop configuration
            //-----------------------------

            // Chose the sensor and direction
            hatchGrabberMotor.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, 0); // extra args are:  primary closed loop, timeout in ms
            hatchGrabberMotor.setSensorPhase(false); //Assume no inversion
            
            // Voltage compensation mode should make 100% output request scale to 12V regardless of battery voltage.
            // (if battery voltage is less than 12v it will just put all available voltage out)
            hatchGrabberMotor.enableVoltageCompensation(true);
            
            // Set the desired 100% at 12V
            hatchGrabberMotor.configVoltageCompSaturation(12.0, 0);
            
            // Encoder setup:  Since we are using the CTRE Mag Encoders, we do not
            // need to configure anything further
            
            // Closed-loop PID initialization/configuration
            //
            // See full code example at https://github.com/CrossTheRoadElec/FRC-Examples-STEAMWORKS/blob/master/JAVA_MotionMagicExample/src/org/usfirst/frc/team217/robot/Robot.java
            // General documentation on CTRE examples at https://github.com/CrossTheRoadElec/Phoenix-Examples-Languages/tree/master/Java

            // set the peak and nominal outputs, -1 to 1 in percentage of nominal voltage (even if battery voltage is higher)
            hatchGrabberMotor.configNominalOutputForward(0.0, 0);
            hatchGrabberMotor.configNominalOutputReverse(-0.0, 0);
            hatchGrabberMotor.configPeakOutputForward(1.0,0);
            hatchGrabberMotor.configPeakOutputReverse(-1.0,0);

            // set closed loop gains in slot0 - see documentation
            hatchGrabberMotor.selectProfileSlot(0,0);

            // Set the closed loop ramp as well (time in seconds to full speed; timeout)
            hatchGrabberMotor.configClosedloopRamp(kAccelTime, 0); //want to get to full speed in x sec

            //Set the closed-loop allowable error.  Empirically on no-load, error was x units.
            hatchGrabberMotor.configAllowableClosedloopError(0, (int) kToleranceDistUnits, 0); // index, err, timeout in ms
            
            // Some packet frames default to updating at 160ms, which is waaaay too slow for our 20ms DS periodic interval!
            // CTRE recommends that you set relevant frame periods to be at least as fast as periodic rate-- their example uses:
            hatchGrabberMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, 0);
            hatchGrabberMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, 0);
            hatchGrabberMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, 0);
            hatchGrabberMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, 0);

            // Set soft limit switches to halt the motor at the extremes of motion
            hatchGrabberMotor.configForwardSoftLimitThreshold((int)kMaxGrabValue);
            hatchGrabberMotor.configForwardSoftLimitEnable(true);
            hatchGrabberMotor.configReverseSoftLimitThreshold((int)kMinGrabValue);
            hatchGrabberMotor.configReverseSoftLimitEnable(true);
            
            // Throw a lot of settings up on the SmartDashboard...
            SmartDashboard.putNumber("Hatch P", kHatchP);
            SmartDashboard.putNumber("Hatch I", kHatchI);
            SmartDashboard.putNumber("Hatch D", kHatchD);
            
            // initialize the current position of the Hatchgrabber as "0" for the sensor.
            // This does imply that the alien hatchgrabber must be in the stowed/released position upon robot power-on!
            // if not, then the current position will become "stowed" and Bad Things will happen.
            resetHatchGrabberEnc();

            hatchGrabberMotor.setInverted(false); // Assume no motor inversion
            //Set the mode to Position.  Second arg is the setpoint.
            //hatchGrabberMotor.set(ControlMode.Position, 0);
            // Put the Talons in "Brake" mode for better accuracy
            hatchGrabberMotor.setNeutralMode(NeutralMode.Brake);
            
            // make sure the motor is off and in open loop mode
            hatchGrabberMotor.set(ControlMode.PercentOutput, 0);

            // get a handle to the Shuffleboard widget for the hatchGrabber encoder
            m_alienTab = Shuffleboard.getTab("Alien"); // Creates tab if it doesn't already exist.
            m_hatchGrabberEncoderEntry = m_alienTab.add("Hatch Enc", 0)
                                                    .withSize(2, 1) // make the widget 2x1
                                                    .withPosition(0, 0) // place it in the top-left corner
                                                    .getEntry();
            m_hatchGrabberEncoderEntry.setDouble(hatchGrabberMotor.getSelectedSensorPosition());
            
            // This is the open-loop value for the motor for manual control and calibration.
            // Used by the HatchGrabOpenMove command button
            m_hatchGrabberMotorOpenMagdirEntry = m_alienTab.add("Hatch Motor", 0)
                                                            .withSize(8, 1) // make the widget 10x1
                                                            .withPosition(2, 0) // place it in the top-left corner
                                                            .withWidget(BuiltInWidgets.kNumberSlider)
                                                            .withProperties(Map.of("min", -0.3, "max", 0.3)) // specify widget properties here                                                    
                                                            .getEntry();
                                                            
            m_hatchGrabberMotorOpenMagdirEntry.setDouble(0);

        // Command to run the HatchGrabber in open-loop mode from the Shuffleboard
        m_alienTab.add("HatchGrabber Open Loop Run", new HatchGrabOpenMove())
        .withSize(4, 1)
        .withPosition(0, 12);

         // Command to reset the hatchGrabber's encoder directly from the Shuffleboard
         m_alienTab.add("Reset Hatch Encoder", new ResetHatchEnc())
         .withSize(6, 1)
         .withPosition(0, 2);
        

        } // If !practicebot
    }
    public void resetHatchGrabberEnc() {
        hatchGrabberMotor.setSelectedSensorPosition(0);
    }

    // Move the hatchGrabber under PID control
    public void hatchGrabberPIDMove(double magDir) {
        // use magDir as the new setpoint for the already-running PID controller
        if ((magDir > kMaxGrabValue) |
            (magDir < kMinGrabValue)) {
                // Error:  we are out of the legal operating range.
                System.out.println("Error:  HatchGrabber setpoint is outside of allowable range.\n" +
                                   "Range min:max = " + kMinGrabValue + ":" + kMaxGrabValue + ", requested value is = " + magDir);
        }
        else {
            this.hatchGrabberMotor.set(ControlMode.Position, magDir);
        }
    }

    // Simple method for moving the hatch motor under "Open loop" control, with magnitude and direction taken directly from Shuffleboard
    public void hatchGrabberOpenMove() {
        double magDir = m_hatchGrabberMotorOpenMagdirEntry.getDouble(0);
        this.hatchGrabberMotor.set(ControlMode.PercentOutput, magDir);
    }

    public void hatchGrabberOpenMove(final double magDir) {
        this.hatchGrabberMotor.set(ControlMode.PercentOutput, magDir);
    }

    public void stop() {
        this.hatchGrabberMotor.set(ControlMode.PercentOutput, 0);
    }

    public State getState() {
        return State.CLOSED;
    }

    public enum State {
        OPENED,
        CLOSED
    }

    //variables for controlling direction
    public static final double stop=0;
    public static final double out=1.0;
    public static final double in=-1.0;

    // Pointer to the Shuffleboard tab for the Arm:
    ShuffleboardTab m_alienTab;
    // Entries for each of the values we want to manipulate in the tab
    NetworkTableEntry m_hatchGrabberEncoderEntry;
    NetworkTableEntry m_hatchGrabberMotorOpenMagdirEntry;

    
}

