// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.DeepSpace2019.subsystems;


import org.usfirst.frc1735.DeepSpace2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.revrobotics.CANPIDController;
import com.revrobotics.CANEncoder;
import com.revrobotics.ControlType;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANError;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Arm extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax armMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANPIDController m_pidController;
    private CANEncoder m_encoder;
  
    public Arm() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        armMotor = new CANSparkMax(5, MotorType.kBrushless);
        
        
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new ArmWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        liveUpdateFromSD();
        SmartDashboard.putNumber("ProcessVariableArm", m_encoder.getPosition()); // Current encoder value (in rotations?)
    }

    public void liveUpdateFromSD() {
         // Put code here to be run every loop
        // read PID coefficients from SmartDashboard
        double p = SmartDashboard.getNumber("P Arm", 0);
        double i = SmartDashboard.getNumber("I Arm", 0);
        double d = SmartDashboard.getNumber("D Arm", 0);
        double iz = SmartDashboard.getNumber("I Zone Arm", 0);
        double ff = SmartDashboard.getNumber("Feed Forward Arm", 0);
        double max = SmartDashboard.getNumber("Max Output Arm", 0);
        double min = SmartDashboard.getNumber("Min OutputArm", 0);
        double rotations = SmartDashboard.getNumber("Set Rotations Arm", 0);

        // if PID coefficients on SmartDashboard have changed, write new values to controller
        if((p != pArm)) { m_pidController.setP(p); pArm = p; }
        if((i != iArm)) { m_pidController.setI(i); iArm = i; }
        if((d != dArm)) { m_pidController.setD(d); dArm = d; }
        if((iz != izArm)) { m_pidController.setIZone(iz); izArm = iz; }
        if((ff != ffArm)) { m_pidController.setFF(ff); ffArm = ff; }
        if((max != maxOutputArm) || (min != minOutputArm)) { 
        m_pidController.setOutputRange(min, max); 
        minOutputArm = min; maxOutputArm = max; 
        }

        /**
         * PIDController objects are commanded to a set point using the 
         * SetReference() method.
         * 
         * The first parameter is the value of the set point, whose units vary
         * depending on the control type set in the second parameter.
         * 
         * The second parameter is the control type can be set to one of four 
         * parameters:
         *  com.revrobotics.ControlType.kDutyCycle
         *  com.revrobotics.ControlType.kPosition
         *  com.revrobotics.ControlType.kVelocity
         *  com.revrobotics.ControlType.kVoltage
         */
        m_pidController.setReference(rotations, ControlType.kPosition);
        
        SmartDashboard.putNumber("SetPoint Arm", rotations);
        // moved to periodic directly
        // SmartDashboard.putNumber("ProcessVariable", m_encoder.getPosition());

    }

    public void initArm() {
        m_pidController = armMotor.getPIDController();

        // Encoder object created to display position values
        m_encoder = armMotor.getEncoder();
        
        // set PID coefficients
        m_pidController.setP(kPArm);
        m_pidController.setI(kIArm);
        m_pidController.setD(kDArm);
        m_pidController.setIZone(kIzArm);
        m_pidController.setFF(kFFArm);
        m_pidController.setOutputRange(kMinOutputArm, kMaxOutputArm);
    
        // display PID coefficients on SmartDashboard
        SmartDashboard.putNumber("P Arm", kPArm);
        SmartDashboard.putNumber("I Arm", kIArm);
        SmartDashboard.putNumber("D Arm", kDArm);
        SmartDashboard.putNumber("I Zone Arm", kIzArm);
        SmartDashboard.putNumber("Feed Forward Arm", kFFArm);
        SmartDashboard.putNumber("Max Output Arm", kMaxOutputArm);
        SmartDashboard.putNumber("Min Output Arm", kMinOutputArm);
        SmartDashboard.putNumber("Set Rotations Arm", 0);
    
    }
    // Simple function to directly control the motor without any PID
    public void simpleMoveArm(double magDir) {
        armMotor.set(magDir);
    }

    // Joystick value modifies PID setting for ARM
    public void PIDMoveArm(double magDir) {
        //magdir is corrected for joystick values before getting here.
        // range is +1 to -1.  We want to map that so that +1 is the forward-most position of the arm/encoder, and -1 is the rearmost (With zero being straight up)
        // Assume (for now) symmetric values for fwd vs backward.
        double setpointArm = magDir * kMaxArmVal;
        m_pidController.setReference(setpointArm, ControlType.kPosition);

    }


    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // Member variables
    // Arm setpoints:
    //    Max rotation is 240', which is +/-120 if zero is Top Dead Center.
    //    Therefore, in rotations, each direction is .33333333 rotations.
    static final double kMaxArmVal = .25; // start with 0.25 so that we don't get close to the hard limits while testing.  We'll sneak up on the final value when tuning.

    // Arm PID coefficients (compiled-in; can override via SD)
    static final double kPArm = 0.3; 
    static final double kIArm = 1e-4;
    static final double kDArm = 0; 
    static final double kIzArm = 0; 
    static final double kFFArm = 0; 
    static final double kMaxOutputArm = 0.4;  // May adjust this higher later...
    static final double kMinOutputArm = -0.4;
    
    // Current Arm PID coefficients (pulled from compile or SD)
    static double pArm = kPArm; 
    static double iArm = kIArm;
    static double dArm = kDArm; 
    static double izArm = kIzArm; 
    static double ffArm = kFFArm; 
    static double maxOutputArm = kMaxOutputArm;  // May adjust this higher later...
    static double minOutputArm = kMinOutputArm;
   
}

