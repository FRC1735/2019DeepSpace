// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc1735.DeepSpace2019.subsystems;

import org.usfirst.frc1735.DeepSpace2019.Robot;
import org.usfirst.frc1735.DeepSpace2019.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;
import edu.wpi.first.wpilibj.shuffleboard.WidgetType;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.DigitalInput;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Arm extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private DigitalInput frontSwingSwitch;
    private DigitalInput backSwingSwitch;
    private WPI_TalonSRX armMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public Arm() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        frontSwingSwitch = new DigitalInput(2);
        addChild("FrontSwingSwitch",frontSwingSwitch);
        
        
        backSwingSwitch = new DigitalInput(3);
        addChild("BackSwingSwitch",backSwingSwitch);
        
        
        armMotor = new WPI_TalonSRX(5);
        
        
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new ArmWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new ArmWithRotarySwitch());
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        if (!Robot.isPracticeBot()) {
            // updatePIDsFromSD(); // optionally update the current PIDs from the SD.
            // Comment out to avoid this.
            // updateSetpointFromSD(); // optionally update the controller setpoint based on
            // above calculations. Comment out to avoid this.

            final int encoderValue = armMotor.getSelectedSensorPosition();
            m_absEncoderEntry.setDouble(encoderValue); // Current absolute encoder val. 1024 ticks/revolution = 2.84444
                                                       // ticks/degree. 256 in 90 degrees.
            m_rawRotaryValue.setDouble(Robot.oi.joyRight.getX());

            final double currentDegrees = ticksToDegrees(encoderValue);
            m_armDegreesEntry.setDouble(currentDegrees);

            if (Math.abs(currentDegrees) < 35) {
                // If our angle is less than 35 degs off of top dead center then use PID slot 0
                armMotor.selectProfileSlot(0, 0);
                m_selectedSlotEntry.setDouble(0);
            } else {
                final double motorOutput = armMotor.getMotorOutputPercent();
                if (motorOutput > 0 && currentDegrees > 0) {
                    armMotor.selectProfileSlot(2, 0); // with gravity on front of robot
                    m_selectedSlotEntry.setDouble(2);
                } else if (motorOutput < 0 && currentDegrees > 0) {
                    armMotor.selectProfileSlot(1, 0); // fighting gravity on front of robot
                    m_selectedSlotEntry.setDouble(1);
                } else if (motorOutput < 0 && currentDegrees < 0) {
                    armMotor.selectProfileSlot(2, 0); // with gravity on back of robot
                    m_selectedSlotEntry.setDouble(2);
                } else if (motorOutput > 0 && currentDegrees < 0) {
                    armMotor.selectProfileSlot(1, 0); // fighting gravity on back of robot
                    m_selectedSlotEntry.setDouble(1);
                } else {
                    // maintain current slot
                }
            }
        }
    }

    // write PIDs from selected slot to SD
    public void writePIDsToSD() {
        // read selected slot from SD
        final int selectedSlot = (int) m_slotIndexEntry.getDouble(0);
        
        // get the values for that slot
        final double p = m_pArm[selectedSlot];
        final double i = m_iArm[selectedSlot];
        final double d = m_dArm[selectedSlot];
        final double iz = m_izArm[selectedSlot];
        final double ff = m_ffArm[selectedSlot];

        // push them to the SD
        m_pArmEntry.setDouble(p);
        m_iArmEntry.setDouble(i);
        m_dArmEntry.setDouble(d);
        m_izArmEntry.setDouble(iz);
        m_ffArmEntry.setDouble(ff);
    }

    // This function causes all thelocal/active PID coefficients and related
    // controller variables to be updated based on whatever's in the SmartDashboard.
    // Can be called in the above periodic() function, or intiated by a Command
    // button on the SmartDashboard
    public void updatePIDsFromSD() {
        // read PID coefficients from SmartDashboard (Arg is the default)
        double p = m_pArmEntry.getDouble(0);
        double i = m_iArmEntry.getDouble(0);
        double d = m_dArmEntry.getDouble(0);
        double iz = m_izArmEntry.getDouble(0);
        double ff = m_ffArmEntry.getDouble(0);
        double max = m_maxOutputArmEntry.getDouble(0);
        double min = m_minOutputArmEntry.getDouble(0);
        int slotIdx = (int) m_slotIndexEntry.getDouble(0);

        // if PID coefficients on SmartDashboard are different from our latest operating
        // values, write the new values to controller and store them locally.
        if ((p != m_pArm[slotIdx])) {
            //System.out.println("Setting arm P for slot " + slotIdx);
            armMotor.config_kP(slotIdx, p, 0);
            m_pArm[slotIdx] = p;
        }
        if ((i != m_iArm[slotIdx])) {
            armMotor.config_kI(slotIdx, i, 0);
            m_iArm[slotIdx] = i;
        }
        if ((d != m_dArm[slotIdx])) {
            armMotor.config_kD(slotIdx, d, 0);
            m_dArm[slotIdx] = d;
        }
        if ((iz != m_izArm[slotIdx])) {
            armMotor.config_IntegralZone(slotIdx, (int) iz, 0);
            m_izArm[slotIdx] = iz;
        }
        if ((ff != m_ffArm[slotIdx])) {
            armMotor.config_kF(slotIdx, ff, 0);
            m_ffArm[slotIdx] = ff;
        }
        if ((max != m_maxOutputArm) || (min != m_minOutputArm)) {
            armMotor.configPeakOutputForward(max, 0);
            armMotor.configPeakOutputReverse(min, 0);
            m_minOutputArm = min;
            m_maxOutputArm = max;
        }
    }

    // Update the setpoint based on the current ARM member variable
    public void updateSetpointFromSD() {
        /**
         * PIDController objects are commanded to a set point using the SetReference()
         * method.
         * 
         * The first parameter is the value of the set point, whose units vary depending
         * on the control type set in the second parameter.
         * 
         * The second parameter is the control type can be set to one of four
         * parameters: com.revrobotics.ControlType.kDutyCycle
         * com.revrobotics.ControlType.kPosition com.revrobotics.ControlType.kVelocity
         * com.revrobotics.ControlType.kVoltage
         */
        double setpointDegrees = degreesToTicks(m_setpointArmEntry.getDouble(0));
        //System.out.println(setpointDegrees);
        // if ((setpointDegrees != m_setpointDegreesArm)) {
        m_setpointDegreesArm = setpointDegrees;
        //System.out.println("Changing ARM setpoint to new value: " + m_setpointDegreesArm);
        armMotor.set(ControlMode.Position, m_setpointDegreesArm);
        // }
    }

    public double degreesToTicks(final double d) {
        final double tarePoint = 120; // this is the intended resting point of the arm in the forward down position
                                      // when against the ground
        final double ticksPerDegree = -2.84;

        final double difference = tarePoint - d;
        final double offset = difference * ticksPerDegree;

        return m_tarePointTicks + offset;
    }

    public double ticksToDegrees(final double ticks) {
        final double ticksPerDegree = 2.84;

        final double shiftedTicks = ticks - kTarePointTicks;
        final double shiftedDegrees = shiftedTicks / ticksPerDegree;

        final double unshiftedDegrees = shiftedDegrees + 120;

        return unshiftedDegrees;
    }

    // this function will reset what the forward most position of the arm is in
    // encoder ticks
    // the intended use is to move the arm into that position and call this function
    // the reason for this function is to compensate in the middle of a match
    // if the encoder gets shifted on the arm such that -512 is no longer straight
    // up and down
    public void tareArm() {
        double oldTarePoint = m_tarePointTicks;
        m_tarePointTicks = armMotor.getSelectedSensorPosition();
        DriverStation.reportWarning(
                "Tared arm, new forward position is: " + m_tarePointTicks + ", old position was: " + oldTarePoint,
                false);
    }

    // One-time initialization of the ARM PID controller and hardware. Called by
    // Robot.robotInit()
    public void initArm() {
        // Motor is mounted so that positive voltages are towards the back of the robot.
        // Want to invert that
        armMotor.setInverted(InvertType.InvertMotorOutput);

        // Put the Talons in "Brake" mode for better accuracy
        armMotor.setNeutralMode(NeutralMode.Brake);

        // Voltage compensation mode should make 100% output request scale to 12V
        // regardless of battery voltage.
        // (if battery voltage is less than 12v it will just put all available voltage
        // out)
        armMotor.enableVoltageCompensation(true);
        // Set the desired 100% at 12V
        armMotor.configVoltageCompSaturation(12.0, 0);
        // set the peak and nominal outputs, -1 to 1 in percentage of nominal voltage
        // (even if battery voltage is higher)
        armMotor.configNominalOutputForward(0.0, 0);
        armMotor.configNominalOutputReverse(-0.0, 0);
        armMotor.configPeakOutputForward(kMaxOutputArm, 0);
        armMotor.configPeakOutputReverse(kMinOutputArm, 0);

        // set closed loop gains in slot0 - see documentation
        armMotor.selectProfileSlot(0, 0);
        // Set the closed loop ramp as well (time in seconds to full speed; timeout)
        armMotor.configClosedloopRamp(kAccelTime, 0); // want to get to full speed in 1/3 sec
        armMotor.configOpenloopRamp(kAccelTime, 0);

        // Set the closed-loop allowable error. Empirically on no-load, error was <50
        // units.
        armMotor.configAllowableClosedloopError(0, (int) kToleranceEncUnits, 0); // index, err, timeout in ms

        // Encoder setup:
        // Chose the sensor and direction
        armMotor.configSelectedFeedbackSensor(FeedbackDevice.Analog, 0, 0); // extra args are: primary closed loop,
                                                                            // timeout in ms
        armMotor.setSensorPhase(false); // true = invert the value.
        armMotor.configFeedbackNotContinuous(false, 0); // prevent the abs encoder from wrapping

        // Some packet frames default to updating at 160ms, which is waaaay too slow for
        // our 20ms DS periodic interval!
        // CTRE recommends that you set relevant frame periods to be at least as fast as
        // periodic rate-- their example uses:
        armMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, 0);
        armMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, 0);
        // Set the initial PID values
        // Slot 0
        kPArm[0] = 10;
        kIArm[0] = 4e-3;
        kDArm[0] = 400;
        kIzArm[0] = 40;
        kFFArm[0] = 0;

        // Slot 1
        kPArm[1] = 4;
        kIArm[1] = 4e-3;
        kDArm[1] = 100;
        kIzArm[1] = 20;
        kFFArm[1] = 0;

        // Slot 2
        kPArm[2] = 4;
        kIArm[2] = 4e-3;
        kDArm[2] = 100;
        kIzArm[2] = 20;
        kFFArm[2] = 0;

        // slot 3
        kPArm[3] = 0;
        kIArm[3] = 0;
        kDArm[3] = 0;
        kIzArm[3] = 0;
        kFFArm[3] = 0;

        for (int i = 0; i <= 3; i++) {
            m_pArm[i] = kPArm[i];
            m_iArm[i] = kIArm[i];
            m_dArm[i] = kDArm[i];
            m_izArm[i] = kIzArm[i];
            m_ffArm[i] = kFFArm[i];
        }

        // display PID coefficients on Shuffleboard (and create references to each entry
        // at the same time)
        // .withWidget(BuiltInWidgets.kNumberSlider)
        // .withProperties(Map.of("min", -0.3, "max", 0.3)) // specify widget properties
        // here
        m_armTab = Shuffleboard.getTab("Arm"); // Creates tab if it doesn't already exist.

        m_pArmEntry = m_armTab.add("P Arm", kPArm[0]).withSize(2, 1) // make the widget 2 wide x1 tall
                .withPosition(0, 0) // col, row
                .getEntry();
        m_iArmEntry = m_armTab.add("I Arm", kIArm[0]).withSize(2, 1).withPosition(2, 0).getEntry();
        m_dArmEntry = m_armTab.add("D Arm", kDArm[0]).withSize(2, 1).withPosition(4, 0).getEntry();
        m_izArmEntry = m_armTab.add("I Zone Arm", kIzArm[0]).withSize(3, 1).withPosition(6, 0).getEntry();
        m_ffArmEntry = m_armTab.add("Feed Forward Arm", kFFArm[0]).withSize(4, 1).withPosition(9, 0).getEntry();
        m_minOutputArmEntry = m_armTab.add("Min Output Arm", kMinOutputArm).withSize(4, 1).withPosition(0, 2)
                .getEntry();
        m_maxOutputArmEntry = m_armTab.add("Max Output Arm", kMaxOutputArm).withSize(4, 1).withPosition(4, 2)
                .getEntry();
        m_setpointArmEntry = m_armTab.add("Set Degrees Arm", 0).withSize(4, 1).withPosition(8, 2).getEntry();
        m_absEncoderEntry = m_armTab.add("Abs Encoder", armMotor.getSelectedSensorPosition()).withSize(4, 1)
                .withPosition(8, 4).getEntry();
        m_simpleArmJoyvalEntry = m_armTab.add("Simple Arm Joyval", 0).withSize(4, 1).withPosition(8, 8).getEntry();

        // Command to trigger a read of all ARM-related variables from Shuffleboard
        m_armTab.add("UpdateArmPIDs", new UpdateArmPIDs()).withSize(4, 1).withPosition(13, 0);
        // Command to force an update of the setpoint from Shuffleboard
        m_armTab.add("UpdateArmSetpoint", new UpdateArmSetpoint()).withSize(4, 1).withPosition(12, 2);
        m_armTab.add("TareArm", new TareArm()).withSize(4, 1).withPosition(12, 3);
        // Raw analog value from rotary switch
        m_rawRotaryValue = m_armTab.add("Raw Rotary Value", 0).withSize(4, 1).withPosition(4, 4).getEntry();

        m_slotIndexEntry = m_armTab.add("Slot Index", 0).withSize(4, 1).withPosition(17, 0).getEntry();

        m_armDegreesEntry = m_armTab.add("Arm Degrees", 0).withSize(2, 1).withPosition(0, 6).getEntry();

        m_selectedSlotEntry = m_armTab.add("Selected Slot", 0).withSize(2, 1).withPosition(2, 6).getEntry();

        m_armTab.add("Get PIDs", new WriteArmPIDFromSlotToSD()).withSize(4, 1).withPosition(17, 4);
    }

    // Simple function to directly control the motor without any PID
    public void simpleMoveArm(double magDir) {
        // magDir comes in as a corrected value from joystick (Y is inverted already),
        // so positive means towards the front of the robot.
        double motorVal;
        if (magDir > 0) {
            motorVal = magDir * Math.abs(m_maxOutputArm);
        } else {
            motorVal = magDir * Math.abs(m_minOutputArm);
        }
        m_simpleArmJoyvalEntry.setDouble(motorVal); // MagDir comes directly from Joysticks (-1 to 1); need to scale to
                                                    // our defined max/min values
        armMotor.set(magDir); // uses open loop mode, when called without a mode.
    }

    // Use this function to use a joystick value to modifies PID setpoint for the
    // ARM
    public void PIDJoyMoveArm(double magDir) {
        // magdir is assumed to be corrected for joystick Y values before getting here.
        // range is +1 to -1. We want to map that so that +1 is the forward-most
        // position of the arm/encoder, and -1 is the rearmost (With zero being straight
        // up)
        // Assume (for now) symmetric values for fwd vs backward.
        double setpointArm = magDir * kMaxArmSwingInDegrees;
        armMotor.set(ControlMode.Position, setpointArm);
    }

    public void PIDMoveArm(double setpointTicks) {
        armMotor.set(ControlMode.Position, setpointTicks);
    }

    public double getSelectedSensorPosition() {
        return armMotor.getSelectedSensorPosition();
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Member variables
    // Pointer to the Shuffleboard tab for the Arm:
    ShuffleboardTab m_armTab;
    // Entries for each of the values we want to manipulate in the tab
    NetworkTableEntry m_pArmEntry;
    NetworkTableEntry m_iArmEntry;
    NetworkTableEntry m_dArmEntry;
    NetworkTableEntry m_ffArmEntry;
    NetworkTableEntry m_izArmEntry;
    NetworkTableEntry m_maxOutputArmEntry;
    NetworkTableEntry m_minOutputArmEntry;
    NetworkTableEntry m_setpointArmEntry; // Change this to modify the setpoint (in rotations)
    NetworkTableEntry m_processVariableArmEntry; // current encoder position (Value? Rotations?)
    NetworkTableEntry m_simpleArmJoyvalEntry; // to print current joystick value for calibration of motor limits
    NetworkTableEntry m_absEncoderEntry; // For absolute encoder values
    NetworkTableEntry m_rawRotaryValue; // for the rotary switch sampled value
    NetworkTableEntry m_slotIndexEntry; // The selected PID slot
    NetworkTableEntry m_armDegreesEntry;
    NetworkTableEntry m_selectedSlotEntry;

    // Arm setpoints:
    // Max rotation is 240', which is +/-120 if zero is Top Dead Center.
    // Therefore, in rotations, each direction is .33333333 rotations of the whole
    // arm, but that's with a 49:1 reduction. sooo...
    static final double kArmGearRatio = 49.0;
    static final double kMaxArmSwingInDegrees = 90; // start with +/- this amount so that we don't get close to the hard
                                                    // limits while testing. We'll sneak up on the final value when
                                                    // tuning.
    static double m_setpointDegreesArm = 0; // for live updates via SD, this is the current/latest setpoint captured.
    static final double kEncoderTicksPerDegree = (1024 / 360); // 4096 encoder ticks per revolution;
    // Stop if we are within this many degrees of the setpoint.
    // Because the motor output goes to neutral when less than this value, our arm
    // will sag when it hits the setpoint!
    // So, set this to zero, which disables the ability for the PID controller to go
    // neutral. it will always hold position.
    static final double kToleranceDegrees = 0;
    static final double kToleranceEncUnits = kToleranceDegrees * kEncoderTicksPerDegree;

    // Arm PID coefficients (compiled-in; can override via SD)
    // Arrayed based on slot number
    static final double[] kPArm = new double[4];
    static final double[] kIArm = new double[4];
    static final double[] kDArm = new double[4];
    static final double[] kIzArm = new double[4];
    static final double[] kFFArm = new double[4];

    static final double kMaxOutputArm = 0.35;
    static final double kMinOutputArm = -0.35;
    static final double kAccelTime = 0.25; // time it takes to reach full speed

    // Current Arm PID coefficients (pulled from compile or SD)
    static double m_pArm[] = new double[4];
    static double m_iArm[] = new double[4];
    static double m_dArm[] = new double[4];
    static double m_izArm[] = new double[4];
    static double m_ffArm[] = new double[4];
    static double m_maxOutputArm = kMaxOutputArm; // May adjust this higher later...
    static double m_minOutputArm = kMinOutputArm;

    // Preset Angles for Arm in Degrees
    public static double kForwardBallPickup = 120;
    public static double kForwardHatchPickup = 87;
    public static double kForwardRocketOne = 70;
    public static double kForwardCargo = 40;
    public static double kForwardRocketTwo = 20;
    public static double kUp = 0;
    public static double kBackwardRocketTwo = -kForwardRocketTwo;
    public static double kBackwardCargo = -kForwardCargo;
    public static double kBackwardRocketOne = -kForwardRocketOne;
    public static double kBackwardHatchPickup = -kForwardHatchPickup;
    public static double kBackwardBallPickup = -kForwardBallPickup;

    // Variables related to taring the arm
    static final double kTarePointTicks = -148;
    double m_tarePointTicks = kTarePointTicks;
}
