// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc1735.DeepSpace2019.subsystems;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANDigitalInput;
import com.revrobotics.CANDigitalInput.LimitSwitchPolarity;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import org.usfirst.frc1735.DeepSpace2019.Robot;
import org.usfirst.frc1735.DeepSpace2019.joysticks.JoystickFactory;
import org.usfirst.frc1735.DeepSpace2019.joysticks.LaunchPadJoystick;
import org.usfirst.frc1735.DeepSpace2019.joysticks.Role;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class AlienDeployer extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax alienDeployerMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANDigitalInput m_forwardLimit;
    private CANDigitalInput m_reverseLimit;
    //private LaunchPadJoystick m_launchPadJoystick;

    public AlienDeployer() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        alienDeployerMotor = new CANSparkMax(7, MotorType.kBrushed);
        
        
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        alienDeployerMotor.setInverted(true);
        m_forwardLimit = alienDeployerMotor.getForwardLimitSwitch(LimitSwitchPolarity.kNormallyOpen);
        m_reverseLimit = alienDeployerMotor.getReverseLimitSwitch(LimitSwitchPolarity.kNormallyOpen);
    
        //m_launchPadJoystick = (LaunchPadJoystick) new JoystickFactory().get(Robot.oi.joyRight, Role.DRIVER_RIGHT);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new AlienDeployWithJoystick());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        // If the reverse limit switch is pressed, then we are retracted.
        // Make sure the reverse timeout flag gets cleared in this case.
        if (m_timeoutDisabled && isReverseLimitPressed()) {
            DriverStation.reportWarning("Alien was disabled but limit switch indicates it is retracted.  Re-enabling.",
                    false);
            this.setTimeoutDisabledFlag(false);
        }

        /*
        LaunchPadJoystick launchPadJoystick = (LaunchPadJoystick) new JoystickFactory().get(Robot.oi.joyRight, Role.DRIVER_RIGHT);
        launchPadJoystick.updateAlienLightState();
        */
    }

    public State getState() {
        if (isReverseLimitPressed()) {
            return State.RETRACTED;
        } else if (isForwardLimitPressed()) {
            return State.EXTENDED;
        } else {
            return State.IN_MOTION;
        }
    }

    // These next two functions are confusing, but are coded as intended.
    // The motor is set to "inverted", meaning that sending a 1 causes it to go
    // backwards.
    // This also has the unfortunate side effect of causing a motor =1 ("forwards")
    // to look at the REVERSE limit switch to halt the motor in hardware!
    // So, we swap the switches going into the motor controller so that the forward
    // limit switch is actually wired to the reverse port.
    // We also need to reverse the SOFTWARE view of the switch as well, which we do
    // here in these two functions
    public boolean isForwardLimitPressed() {
        return m_reverseLimit.get(); // yes, we really intend to look at the reverse limit switch value due to the
                                     // motor inversion.
    }

    public boolean isReverseLimitPressed() {
        return m_forwardLimit.get(); // yes, we really intend to look at the forward limit switch value due to the
                                     // motor inversion.
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void alienDeployerMove(double magDir) {
        // System.out.println("alienDeployerMove with magDir= " + magDir);
        if ((magDir == AlienDeployer.in) && this.getTimeoutDisabledFlag()) {
            DriverStation.reportWarning("Alien is disabled due to retraction timeout!", false);
        } else {
            alienDeployerMotor.set(magDir);
        }
        // if (m_forwardLimit.get()) {
        // System.out.println("forward limit hit");
        // }
        // if (m_reverseLimit.get()) {
        // System.out.println("reverse limit hit");
        // }

    }

    public enum State {
        EXTENDED, RETRACTED, IN_MOTION
    }

    // AlienDeploy command may set this if the retraction timed out.
    // perodic for this class can clear the flag if the reverse limit switch is
    // triggered.
    public void setTimeoutDisabledFlag(boolean newState) {
        m_timeoutDisabled = newState;
    }

    public boolean getTimeoutDisabledFlag() {
        return m_timeoutDisabled;
    }

    // variables for controlling direction
    public static final double stop = 0;
    public static final double out = 1.0;
    public static final double in = -1.0;

    // TODO - these may need to be adjusted
    static final double kExtendedPosition = 1;
    static final double kRetractedPosition = 0;

    // Timeout safety
    boolean m_timeoutDisabled = false; // Default to normal state
}
