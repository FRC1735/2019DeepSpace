// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.DeepSpace2019.commands;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc1735.DeepSpace2019.Robot;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import java.util.ArrayList;
import java.util.List;

import org.usfirst.frc1735.DeepSpace2019.subsystems.DriveTrain;
import org.usfirst.frc1735.DeepSpace2019.utils.PairOfDoubles;

import com.ctre.phoenix.ParamEnum;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;

/**
 *
 */
public class DriveWithPID extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double m_distance;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveWithPID(double distance) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_distance = distance;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        // Init dynamic variable
        m_distHistory = new ArrayList<>();
    }

    //Void constructor gets distance from SmartDashboard.  Allows us to use a button (w/ no preset) to call the command
    public DriveWithPID() {
    	//System.out.println("DriveWithPID Null constructor called");
		m_getDistFromSmartDashboard = true;
		m_activeSide = ActiveSide.BOTH;
        requires(Robot.driveTrain);
   }
    
    // Use this if driving to a cube using the camera
    public DriveWithPID(boolean isWithCamera) {
    	if (isWithCamera) {
    		m_getDistFromCamera = true;
    	}
    	else {
    		// Ummm... punt and pretend this was a null constructor and get data from the SmartDashboard...?\
        	m_getDistFromSmartDashboard = true;
		}
		m_activeSide = ActiveSide.BOTH;
        requires(Robot.driveTrain);    	
	}
	
	public DriveWithPID(final double distance, final ActiveSide activeSide) {
		this.m_distance = distance;
		this.m_activeSide = activeSide;

		requires(Robot.driveTrain);
	}    

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	//Set the driveline's Talons into MotionMagic mode
		Robot.driveTrain.setPIDMode(); // This also turns off the motors as part of the mode switch.
		m_distHistory = new ArrayList<>();
    	//extract the PID values for this command
    	double p = SmartDashboard.getNumber("P", 0);
    	double i = SmartDashboard.getNumber("I", 0);
    	double d = SmartDashboard.getNumber("D", 0);
		double f = SmartDashboard.getNumber("F", 0.3789);
		
		final int izone = 350;
		Robot.driveTrain.getLeftMotor().config_IntegralZone(0, izone, 0);
		Robot.driveTrain.getRightMotor().config_IntegralZone(0, izone, 0);

		Robot.driveTrain.getLeftMotor().config_kP(0, p, 0); // Slot, value, timeout in ms
    	Robot.driveTrain.getLeftMotor().config_kI(0, i, 0); // Slot, value, timeout in ms
    	Robot.driveTrain.getLeftMotor().config_kD(0, d, 0); // Slot, value, timeout in ms
    	Robot.driveTrain.getLeftMotor().config_kF(0, f, 0); // Slot, value, timeout in ms
    	Robot.driveTrain.getRightMotor().config_kP(0, p, 0); // Slot, value, timeout in ms
    	Robot.driveTrain.getRightMotor().config_kI(0, i, 0); // Slot, value, timeout in ms
    	Robot.driveTrain.getRightMotor().config_kD(0, d, 0); // Slot, value, timeout in ms
    	Robot.driveTrain.getRightMotor().config_kF(0, f, 0); // Slot, value, timeout in ms
    	
    	// Initialize the desired max speed and acceleration:
    	m_magDir = (int) SmartDashboard.getNumber("Cruise SpeedDir", 2700); // default to full speed
    	Robot.driveTrain.getLeftMotor().configMotionCruiseVelocity(m_magDir, 0);  // speed in encoder units per 100ms
    	Robot.driveTrain.getRightMotor().configMotionCruiseVelocity(m_magDir, 0);
    	
    	m_accel = (int) SmartDashboard.getNumber("Cruise Accel", 5400); //full speed in 1/2 sec (was 8100 = 1/3)
		int r_accel = (int) SmartDashboard.getNumber("Cruise R Accel", 5400); //was 10000
		
    	// If we created this command without args, it should get its distance from the SmartDashboard:
    	// (if not, it was already passed in from the parent CommandGroup and set in the constructor)
    	if (m_getDistFromSmartDashboard) { 
    		m_distance = SmartDashboard.getNumber("Cruise Dist", 18.849); // default:  one revolution of a 6" wheel is just short of 19"
    		System.out.println("Initializing drive distance from SmartDashboard");
    	}
		
		// compensate for acceleration differences between motors
		if (m_distance > 0) {
			Robot.driveTrain.getLeftMotor().configMotionAcceleration(m_accel, 0); //want xPM in 1 sec, so x/60/10*4096 = 3072 units/100ms
			Robot.driveTrain.getRightMotor().configMotionAcceleration(r_accel, 0);
		} else {
			Robot.driveTrain.getLeftMotor().configMotionAcceleration(r_accel, 0); //want xPM in 1 sec, so x/60/10*4096 = 3072 units/100ms
			Robot.driveTrain.getRightMotor().configMotionAcceleration(m_accel, 0);
		}
				
    	// We also can get distance from the camera
    	if (m_getDistFromCamera) {
    		m_distance = 0; // was (int) Robot.driveTrain.getDistanceToCube();
    		System.out.println("Initializing drive distance from Camera");
    	}

    	//Set a timeout value in seconds
    	setTimeout(4);
    	
    	// initialize a loop iteration counter (used in isFinished(); see below)
    	m_loopCount = 0;
    	    	
    	// Calculate the "encoder distance".  our command input is in something human-readable:  Inches.
    	// But the HW PID controller wants distance in encoder units.
    	m_encDistance = m_distance * DriveTrain.kEncoderTicksPerInch;
    	    	
    	System.out.println("DriveWithPID has been requested for " + m_distance + " inches, or " + m_encDistance + " encoder ticks");

		if (m_activeSide.equals(ActiveSide.LEFT)) {
			//Robot.driveTrain.getLeftMotor().config_kP(0, 3, 0);
			Robot.driveTrain.getLeftMotor().set(ControlMode.MotionMagic, m_encDistance);
			//Robot.driveTrain.getRightMotor().set(ControlMode.MotionMagic, 0);	
			Robot.driveTrain.getRightMotor().setNeutralMode(NeutralMode.Coast);
		} else if (m_activeSide.equals(ActiveSide.RIGHT)) {
			//Robot.driveTrain.getRightMotor().config_kP(0, 3, 0);
			//Robot.driveTrain.getLeftMotor().set(ControlMode.MotionMagic, 0);
			Robot.driveTrain.getRightMotor().set(ControlMode.MotionMagic, m_encDistance);	
			Robot.driveTrain.getLeftMotor().setNeutralMode(NeutralMode.Coast);
		} else {
			Robot.driveTrain.getLeftMotor().set(ControlMode.MotionMagic, m_encDistance);
			Robot.driveTrain.getRightMotor().set(ControlMode.MotionMagic, m_encDistance);
		}
	}

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	// Increment the loop count (used in isFinished(); see below)
    	m_loopCount++;
   }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	//  update our rolling average distance traveled.  We need to compare this AVERAGE when deciding when to terminate.
		PairOfDoubles avgDistPair = calcAvgDist(Robot.driveTrain.getLeftMotor().getSelectedSensorPosition(0),
												Robot.driveTrain.getRightMotor().getSelectedSensorPosition(0));

   	
    	// The most intuitive thing to check would be the closed loop error, and if it's less than the allowable error we're done.
    	// However, the first ~5 iterations (@20ms, this is about 100ms) don't report accurate CLerr, so we'll avoid that and instead check if our sensor position is within the allowed error of the setpoint.
    	// Unfortunately, the first iteration of the command hasn't yet actually seen the zeroed out sensor and will see whatever position was present prior to starting this command.
		// So, we need to skip checking anything on the first iteration.
		final double leftEncoderDistance = (m_activeSide.equals(ActiveSide.LEFT) || m_activeSide.equals(ActiveSide.BOTH)) ? m_encDistance : 0;
		final double rightEncoderDistance = (m_activeSide.equals(ActiveSide.RIGHT) || m_activeSide.equals(ActiveSide.BOTH)) ? m_encDistance : 0;
    	boolean distReachedLeft = (Math.abs(avgDistPair.getLeft()- leftEncoderDistance) < DriveTrain.kToleranceDistUnits);
    	boolean distReachedRight = (Math.abs(avgDistPair.getRight() - rightEncoderDistance) < DriveTrain.kToleranceDistUnits);

		if  (Robot.isDbgOn()) { // Use variable rather than print wrapper so that we also avoid all the CAN bus queries...
			System.out.println(
				" loopCount: " + m_loopCount + "\n" +
			    " FLerr: " + Robot.driveTrain.getLeftMotor().getClosedLoopError(0) +
					" out_pct: " + Robot.driveTrain.getLeftMotor().getMotorOutputPercent() +
					//" CLTarget: " + Robot.driveTrain.getLeftMotor().getClosedLoopTarget(0) +
					" Pos: " + Robot.driveTrain.getLeftMotor().getSelectedSensorPosition(0) +
					//" Vel: " + Robot.driveTrain.getLeftMotor().getSelectedSensorVelocity(0) + 
					//" Mode: " + Robot.driveTrain.getLeftMotor().getControlMode() + 
					" AvgDistL: " + avgDistPair.getLeft() + 
					" distReachedLeft: " + distReachedLeft + "\n" +
					" FRerr: " + Robot.driveTrain.getRightMotor().getClosedLoopError(0) +
					" out_pct: " + Robot.driveTrain.getRightMotor().getMotorOutputPercent() +
					" Pos: " + Robot.driveTrain.getRightMotor().getSelectedSensorPosition(0) +
					//" Vel: " + Robot.driveTrain.getRightMotor().getSelectedSensorVelocity(0) +
					//" Mode: " + Robot.driveTrain.getLeftMotor().getControlMode() +
					" AvgDistR: " + avgDistPair.getRight() +
					" distReachedRight: " + distReachedRight + "\n");
		}

		//   	System.out.println(" leftMotor.configGetParameter: " +  
      	//	  Robot.driveTrain.getLeftMotor().configGetParameter(ParamEnum.eProfileParamSlot_AllowableErr, 315, 0));


		if (m_loopCount > 1) //The first execute will inc to 1, so the first isFinished will see 1 as well.  this is the iteration we want to skip.
			// Want both left and right sides to have reached their goal before stopping.
    		return (distReachedLeft && distReachedRight) || isTimedOut();
    	else
    		return false; // On the first iteration, don't terminate (we have no valid data upon which to calculate a termination value!)
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    	Robot.driveTrain.setOpenLoopMode(); // This also turns off the motors as part of the mode switch
    	
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
    
    // Given a new distance on each encoder, calculate a new rolling average.
    protected PairOfDoubles calcAvgDist(int latestDistLeft, int latestDistRight) {
    	// Remove the oldest item in the distHistory (if too many exist)
    	while (m_distHistory.size() > 10) // Rolling average of n items 0..(n-1)
    		m_distHistory.remove(0);
    	
    	// Add the latest distance to the list
    	m_distHistory.add(new PairOfDoubles((double)latestDistLeft, (double)latestDistRight));
    	
    	// Calculate the new average
		double newSumLeft =  0;
		double newSumRight = 0;
    	for (int i=0; i< m_distHistory.size(); i++) {
    		newSumLeft = newSumLeft + m_distHistory.get(i).getLeft();
    		newSumRight = newSumRight + m_distHistory.get(i).getRight();
    	}

    	double newAvgLeft = newSumLeft / m_distHistory.size();
    	double newAvgRight = newSumRight / m_distHistory.size();
    	return new PairOfDoubles(newAvgLeft, newAvgRight);
    }
    
    // Member Variables
    int m_magDir;
    int m_accel;
    boolean m_getDistFromSmartDashboard = false;
    boolean m_getDistFromCamera = false;
	double m_loopCount;
	
    double m_encDistance; // This is the requested distance in encoder ticks, as opposed to m_distance which is in inches.
	private List<PairOfDoubles> m_distHistory;  // Holds a history of previous sensor distance values
	ActiveSide m_activeSide = ActiveSide.BOTH;

	public enum ActiveSide {
		LEFT,
		RIGHT,
		BOTH
	}
}
